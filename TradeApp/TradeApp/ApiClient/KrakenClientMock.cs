using Jayrock.Json;
using log4net;
using System;
using System.Collections.Generic;
using System.ComponentModel.Composition;
using System.Configuration;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using TradeApp.ConnectorService;
using TradeApp.DataAccess;
using TradeApp.Model;

namespace TradeApp.ApiClient
{
    [Export(typeof(IExchangeClient))]
    public class KrakenClientMock : ExchangeClientBase, IExchangeClient
    {
        ILog _logger;
        int _maxRetries;
        private System.Timers.Timer _timer;
        
        decimal[] _weekDayCountAverages;
        decimal[] _weekEndCountAverages;
        decimal[] _weekDayVolumeAverages;
        decimal[] _weekDayVolumeStdDevs;
        decimal oldPrice = 300;

        //Order book for our mock client. When an order is received from the brokerage service, we add it to this list. Whenever the trade-generating bot creates a new trade,
        //we check it agains this order book, to see if the order's status should be updated (filled, partially-filled...)
        List<Orders> _orders;
        //a list of trades generated by the trade-generating bot. When  new trade is added, we check to see if it corresponds to an order in the order book. WHen checking past data (GetPricePoints and GetCandleStick),
        //we query this list of trades.
        List<PricePoint> _trades;

        static Random _rnd;
        static Random Rnd
        {
            get 
            {
                if (_rnd == null)
                    _rnd = new Random();
                return _rnd;
            }
        }

        public KrakenClientMock()
        {
            _logger = LogManager.GetLogger("KrakenClientMock");
            _maxRetries = int.Parse(ConfigurationManager.AppSettings["KrakenClientMaxRetries"]);
            base.Name = "Kraken Mock";

            _orders = new List<Orders>();
            _trades = new List<PricePoint>();

            #region COUNT AVERAGES

            _weekDayCountAverages = new decimal[24]
            {
                62.57m,
                55.34m,
                48.38m,
                42.30m,
                44.19m,
                58.87m,
                76.73m,
                104.29m,
                116.10m,
                124.05m,
                143.297m,
                137.63m,
                139.73m,
                131.80m,
                129.73m,
                128.54m,
                121.12m,
                111.73m,
                111.50m,
                107.35m,
                112.37m,
                108.01m,
                91.71m,
                76.92m};

            _weekEndCountAverages = _weekDayCountAverages;

            #endregion

            #region VOLUME AVERAGES

            _weekDayVolumeAverages = new decimal[]
            {
                0.324249318m,
                0.304481896m,
                0.277974134m,
                0.296968911m,
                0.29353184m,
                0.308256405m,
                0.339259792m,
                0.34154558m,
                0.359686847m,
                0.353301515m,
                0.351548929m,
                0.359428892m,
                0.363288654m,
                0.348266785m,
                0.358002518m,
                0.359891368m,
                0.368993123m,
                0.355755981m,
                0.356752178m,
                0.368679276m,
                0.342272549m,
                0.32527729m,
                0.345123725m,
                0.339257534m
            };

            _weekDayVolumeStdDevs = new decimal[]
            {
                0.873468116m,
                0.855025448m,
                0.754214126m,
                0.781441174m,
                0.831088845m,
                0.778278614m,
                0.85759711m,
                0.931890404m,
                0.900028126m,
                0.927843053m,
                0.909811074m,
                0.887112288m,
                0.945847689m,
                0.861897238m,
                0.916189384m,
                0.938623332m,
                0.904357608m,
                0.896229559m,
                0.903679498m,
                0.91507197m,
                0.913234175m,
                0.842657287m,
                0.925557979m,
                1.017814177m
            };

            #endregion
        }

        #region IExchangeClient Members

        //Catch up with past data and start trade bot
        public IList<PricePoint> CatchUp()
        {
            var start = (DateTimeOffset.Now).Subtract(new TimeSpan(30, 0, 0, 0));
            
            var pricePoints = new List<PricePoint>();

            DateTimeOffset time = start;
            double amount;
            decimal price;

            while (time < DateTimeOffset.Now)
            {
                #region Time of next trade (Non homogeneous Poisson Process)

                var hoursToNextTrade = HoursToNextTrade(time.UtcDateTime);

                time = time.AddHours(hoursToNextTrade);

                #endregion

                #region Amount
                //Get amount
                var amountStats = GetAmountAverageAndStdDev(time.DateTime);
                var amountAverage = amountStats.Average;
                var amountStdDev = amountStats.StdDev;

                //mu + sigma*N(0,1)
                var normal = amountAverage + amountStdDev * StandardNormal(Rnd);

                //exp(Normal) ~ LogNormal
                var logNormal = Math.Exp((double)normal);

                amount = logNormal;
                #endregion

                #region Price
                //Get Price

                //annual return
                decimal mu = 0.0004m;
                //annual volatility
                decimal sigma = 0.3786m;
                //dt
                decimal dt = (decimal)hoursToNextTrade / (24 * 365);


                price = oldPrice * (1 + mu * dt + sigma * (decimal)Math.Sqrt((double)dt) * StandardNormal(Rnd));

                oldPrice = price;

                #endregion

                var pricePoint = new PricePoint(time, price, amount);

                pricePoints.Add(pricePoint);
            }

            _trades.AddRange(pricePoints);

            RunTradeBot();

            return pricePoints;
        }

        public IList<PricePoint> GetPricePoints(DateTimeOffset start, DateTimeOffset? end)
        {
            
            //fetch from _trades
            var result = _trades.Where(p =>( p._Time >= start) && (p._Time <= (end ?? DateTimeOffset.Now))).ToList();

            return result;
        }

        public GetCandleStickResult GetCandleStick(long last)
        {

            GetCandleStickResult candleStickResult = new GetCandleStickResult();

            DateTimeOffset openTime = PricePoint.UnixTimeNanoSecondsToDateTime(last.ToString());
            DateTimeOffset closeTime = DateTimeOffset.Now;

            var pricePoints = GetPricePoints(openTime, closeTime);

            CandleSticks candleStick = null;
            if (pricePoints != null && pricePoints.Count > 0)
            {

                decimal openPrice = pricePoints.First()._Price;
                decimal closePrice = pricePoints.Last()._Price;
                decimal high = pricePoints.Max(p => p._Price);
                decimal low = pricePoints.Min(p => p._Price);

                candleStick = new CandleSticks(openTime, closeTime, openPrice, high, low, closePrice);
                last = PricePoint.DateTimeToUnixTimeNonoseconds(pricePoints.Last()._Time);
            }
            else
            {
                last = PricePoint.DateTimeToUnixTimeNonoseconds(DateTimeOffset.Now);
            }

            candleStickResult.ResultType = GetCandleStickResultType.success;
            candleStickResult.CandleStick = candleStick;
            candleStickResult.Last = last;

            return candleStickResult;

        }

        public PlaceOrderResult PlaceOrder(Orders order, bool wait)
        {
            PlaceOrderResult placeOrderResult = new PlaceOrderResult();
            placeOrderResult.Order = order;

            try
            {
                order.Status = "open";
                _orders.Add(order);

                var newOrder = order;

                if (wait)
                {
                    #region repeatedly check order status
                    bool keepSpinning = true;
                    while (keepSpinning)
                    {
                        newOrder = _orders.Where(o => o.Id == order.Id).FirstOrDefault();
                        placeOrderResult.Order = newOrder;
                        switch (newOrder.Status)
                        {
                            case "closed":
                                placeOrderResult.ResultType = PlaceOrderResultType.success;
                                return placeOrderResult;
                            case "partial":
                                //keep spinning
                                break;
                            case "canceled":
                                placeOrderResult.ResultType = PlaceOrderResultType.canceled_not_partial;
                                return placeOrderResult;
                            default:
                                break;
                        }

                        Thread.Sleep(5000);
                    }
                    #endregion
                }

                placeOrderResult.ResultType = PlaceOrderResultType.success;
                placeOrderResult.Order = newOrder;
                return placeOrderResult;
            }
            catch (Exception ex)
            {
                placeOrderResult.ResultType = PlaceOrderResultType.exception;
                placeOrderResult.Exception = ex;
                return placeOrderResult;
            }
            
        }

        public CancelOrderResult CancelOrder(Orders order)
        {
            CancelOrderResult cancelOrderResult = new CancelOrderResult();
            try
            {
                var existingOrder = _orders.FirstOrDefault(o => o.Id == order.Id);
                if (existingOrder != null)
                {
                    //recall that this modifies the object inside the list (it is a reference)
                    existingOrder.Status = "canceled";
                    cancelOrderResult.ResultType = CancelOrderResultType.success;
                    cancelOrderResult.Order = existingOrder;
                }
                else
                {
                    cancelOrderResult.ResultType = CancelOrderResultType.error;
                    cancelOrderResult.Errors = new List<string>() { string.Format("order {0} not found", order.Id) };
                }

                return cancelOrderResult;
            }
            catch (Exception ex)
            {
                cancelOrderResult.ResultType = CancelOrderResultType.exception;
                cancelOrderResult.Exception = ex;
                return cancelOrderResult;
            }
        }

        public void HandleException(Exception exception)
        {
            throw new NotImplementedException();
        }

        public void HandleErrors(List<string> errors)
        {

        }

        #endregion

        #region Trade bot
        
        //simulate trading activity (frequency, price and volume of trades occuring on the exchange)
        void RunTradeBot()
        {
            if (_timer != null && _timer.Enabled)
                return;

            try
            {

                #region Time of next trade (Non homogeneous Poisson Process)

                var time = DateTimeOffset.UtcNow;

                double hoursToNextTrade = HoursToNextTrade(time.UtcDateTime);

                time = time.AddHours(hoursToNextTrade);

                #endregion

                var timerMilliSeconds = hoursToNextTrade * 60 * 60 * 1000;

                _timer = new System.Timers.Timer(timerMilliSeconds);

                _timer.Elapsed += (s, e) =>
                {

                    #region Add point to trades

                    double amount = 0.0;
                    decimal price = 0;

                    #region Amount
                    //Get amount
                    var amountStats = GetAmountAverageAndStdDev(time.DateTime);
                    var amountAverage = amountStats.Average;
                    var amountStdDev = amountStats.StdDev;

                    //mu + sigma*N(0,1)
                    var normal = amountAverage + amountStdDev * StandardNormal(Rnd);

                    //exp(Normal) ~ LogNormal
                    var logNormal = Math.Exp((double)normal);

                    amount = logNormal;
                    #endregion

                    #region Price
                    //Get Price

                    //annual return
                    decimal mu = 0.0004m;
                    //annual volatility
                    decimal sigma = 0.3786m;
                    //dt
                    decimal dt = (decimal)hoursToNextTrade / (24 * 365);


                    price = oldPrice * (1 + mu * dt + sigma * (decimal)Math.Sqrt((double)dt) * StandardNormal(Rnd));

                    oldPrice = price;

                    #endregion

                    var pricePoint = new PricePoint(time, price, amount);

                    _trades.Add(pricePoint);

                    #endregion

                    //Check orders
                    decimal remainingTradeAmount = (decimal)pricePoint._Amount;

                    if (remainingTradeAmount > 0)
                    {
                        //This is a shortcut because we know that BrokerageService should only have one position at a time. We could implement a full order book
                        //but that introduces issues with knowing which order arrived first, cascade fill...etc (do this later if there is time)
                        var pendingOrder = _orders.SingleOrDefault(o=>o.Status == "open");
                        if (pendingOrder != null)
                        {                           
                                switch (pendingOrder.OrderType)
                                {
                                    case "stop-loss":
                                        
                                        if( (pendingOrder.Type == "buy" && (pendingOrder.Price <= pricePoint._Price)) ||
                                            (pendingOrder.Type == "sell" && (pendingOrder.Price >= pricePoint._Price)))
                                    
                                        {
                                                decimal remainingOrderVolume = pendingOrder.Volume - (pendingOrder.VolumeExecuted??0) ;
                                                    
                                                if(remainingOrderVolume <= remainingTradeAmount) //the order is fully covered by the reamining trade amount
                                                {
                                                    pendingOrder.VolumeExecuted = pendingOrder.Volume;
                                                    pendingOrder.Status = "closed";

                                                    remainingTradeAmount -= remainingOrderVolume;
                                                }
                                                else // the order can only be partially filled
                                                {
                                                    pendingOrder.VolumeExecuted += remainingTradeAmount;
                                                    pendingOrder.Status = "partial";

                                                    remainingTradeAmount = 0;
                                                }
                                       }
   
                                        break;
                                    case "market":
                                        {
                                            decimal remainingOrderVolume = pendingOrder.Volume - (pendingOrder.VolumeExecuted??0) ;
                                                    
                                            if(remainingOrderVolume <= remainingTradeAmount) //the order is fully covered by the reamining trade amount
                                            {
                                                pendingOrder.VolumeExecuted = pendingOrder.Volume;
                                                pendingOrder.Status = "closed";

                                                remainingTradeAmount -= remainingOrderVolume;
                                            }
                                            else // the order can only be partially filled
                                            {
                                                pendingOrder.VolumeExecuted += remainingTradeAmount;
                                                pendingOrder.Status = "partial";

                                                remainingTradeAmount = 0;
                                            }
                                            break;
                                        }
                                }                            
                        }
                    }

                    #region Reset timer
                    hoursToNextTrade = HoursToNextTrade(time.UtcDateTime);
                    time = time.AddHours(hoursToNextTrade);
                    _timer.Interval = hoursToNextTrade * 60 * 60 * 1000;
                    _timer.Start(); 
                    #endregion
                };


                _timer.Start();
            }
            catch (Exception ex)
            {
                if (_timer != null)
                    _timer.Stop();
                Log(LogEntryImportance.Error, "There was an error. KrakenClientMock timer stopped. \n Details: " + ex.Message);
                throw;
            }
            
        }

        #endregion

        #region Helpers

        double HoursToNextTrade(DateTime t0)
        {
            
            //Get lambda(time): Average number of trades per hour
            double lambda = (double)Lambda(t0);

            //simulate exponential lambda(time), they need to be independant
            var u = Rnd.NextDouble();

            var expo = -Math.Log(u) / lambda; // hours till next trade

            return expo;
        }

        decimal Lambda(DateTime time)
        {
            var dayOfWeek = time.DayOfWeek;
            int hourOfDay = time.Hour;
            
            decimal lambda =0;
            if ((int)dayOfWeek != 0 && (int)dayOfWeek != 6) // sunday=0, saturday=6
            {
                lambda = _weekDayCountAverages[hourOfDay];
            }
            else 
            {
                lambda = _weekEndCountAverages[hourOfDay];
            }

            return lambda;
        }

        dynamic GetAmountAverageAndStdDev(DateTime time)
        {
            var dayOfWeek = time.DayOfWeek;
            int hourOfDay = time.Hour;

            decimal average = _weekDayVolumeAverages[hourOfDay];
            decimal stdDev = _weekDayVolumeStdDevs[hourOfDay];

            return new { Average = average, StdDev = stdDev };
        }

        //Box-Muller
        decimal StandardNormal(System.Random rnd)
        {
            var u = rnd.NextDouble();
            var v = rnd.NextDouble();

            var f = Math.Sqrt(-2 * Math.Log(u));

            //x ~ N(0,1)
            var x = f * Math.Cos(2 * Math.PI * v);

            return (decimal)x;
        }

        protected void Log(LogEntryImportance importance, string message)
        {

            //log to file
            switch (importance)
            {
                case LogEntryImportance.Info:
                    _logger.Info(message);
                    break;
                case LogEntryImportance.Debug:
                    _logger.Debug(message);
                    break;
                case LogEntryImportance.Error:
                    _logger.Error(message);
                    break;
            }

        } 
        #endregion
    }
}
